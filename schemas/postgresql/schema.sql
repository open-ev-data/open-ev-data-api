-- OpenEV Data PostgreSQL Schema
-- Reference schema for PostgreSQL database
-- Generated by ev-etl

BEGIN;

-- Main vehicles table
CREATE TABLE IF NOT EXISTS vehicles (
    id SERIAL PRIMARY KEY,
    unique_code VARCHAR(255) UNIQUE NOT NULL,
    
    -- Identification
    make_slug VARCHAR(100) NOT NULL,
    make_name VARCHAR(255) NOT NULL,
    model_slug VARCHAR(100) NOT NULL,
    model_name VARCHAR(255) NOT NULL,
    year INTEGER NOT NULL CHECK (year >= 1900 AND year <= 2100),
    trim_slug VARCHAR(100) NOT NULL,
    trim_name VARCHAR(255) NOT NULL,
    variant_slug VARCHAR(100),
    variant_name VARCHAR(255),
    
    -- Classification
    vehicle_type VARCHAR(50) NOT NULL,
    
    -- Powertrain
    drivetrain VARCHAR(20) NOT NULL,
    system_power_kw DECIMAL(10,2),
    system_torque_nm DECIMAL(10,2),
    
    -- Battery
    battery_capacity_gross_kwh DECIMAL(10,2),
    battery_capacity_net_kwh DECIMAL(10,2),
    battery_chemistry VARCHAR(100),
    
    -- Charging
    dc_max_power_kw DECIMAL(10,2),
    ac_max_power_kw DECIMAL(10,2),
    
    -- Range
    range_wltp_km DECIMAL(10,2),
    range_epa_km DECIMAL(10,2),
    
    -- Performance
    acceleration_0_100_s DECIMAL(5,2),
    top_speed_kmh DECIMAL(10,2),
    
    -- Full JSON data (JSONB for querying)
    json_data JSONB NOT NULL,
    
    -- Metadata
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- Charge ports table
CREATE TABLE IF NOT EXISTS charge_ports (
    id SERIAL PRIMARY KEY,
    vehicle_id INTEGER NOT NULL REFERENCES vehicles(id) ON DELETE CASCADE,
    kind VARCHAR(50) NOT NULL,
    connector VARCHAR(50) NOT NULL,
    location_side VARCHAR(50),
    location_position VARCHAR(50)
);

-- Range ratings table
CREATE TABLE IF NOT EXISTS range_ratings (
    id SERIAL PRIMARY KEY,
    vehicle_id INTEGER NOT NULL REFERENCES vehicles(id) ON DELETE CASCADE,
    cycle VARCHAR(50) NOT NULL,
    range_km DECIMAL(10,2) NOT NULL,
    notes TEXT
);

-- Data sources table
CREATE TABLE IF NOT EXISTS sources (
    id SERIAL PRIMARY KEY,
    vehicle_id INTEGER NOT NULL REFERENCES vehicles(id) ON DELETE CASCADE,
    source_type VARCHAR(50) NOT NULL,
    title TEXT NOT NULL,
    url TEXT NOT NULL,
    accessed_at TIMESTAMP WITH TIME ZONE NOT NULL,
    publisher VARCHAR(255)
);

-- B-tree indexes for exact matches
CREATE INDEX IF NOT EXISTS idx_vehicles_make ON vehicles(make_slug);
CREATE INDEX IF NOT EXISTS idx_vehicles_model ON vehicles(model_slug);
CREATE INDEX IF NOT EXISTS idx_vehicles_year ON vehicles(year);
CREATE INDEX IF NOT EXISTS idx_vehicles_composite ON vehicles(make_slug, model_slug, year, trim_slug);
CREATE INDEX IF NOT EXISTS idx_vehicles_type ON vehicles(vehicle_type);
CREATE INDEX IF NOT EXISTS idx_vehicles_unique_code ON vehicles(unique_code);

-- GIN index for JSONB queries
CREATE INDEX IF NOT EXISTS idx_vehicles_json ON vehicles USING GIN (json_data);

-- Partial indexes for common filters
CREATE INDEX IF NOT EXISTS idx_vehicles_recent ON vehicles(year) WHERE year >= 2020;
CREATE INDEX IF NOT EXISTS idx_vehicles_electric ON vehicles(battery_capacity_net_kwh) WHERE battery_capacity_net_kwh IS NOT NULL;

-- Foreign key indexes
CREATE INDEX IF NOT EXISTS idx_charge_ports_vehicle ON charge_ports(vehicle_id);
CREATE INDEX IF NOT EXISTS idx_range_ratings_vehicle ON range_ratings(vehicle_id);
CREATE INDEX IF NOT EXISTS idx_sources_vehicle ON sources(vehicle_id);

-- Full-text search using tsvector
ALTER TABLE vehicles ADD COLUMN IF NOT EXISTS search_vector tsvector;

CREATE OR REPLACE FUNCTION vehicles_search_trigger() RETURNS trigger AS $$
BEGIN
    NEW.search_vector := 
        setweight(to_tsvector('english', COALESCE(NEW.make_name, '')), 'A') ||
        setweight(to_tsvector('english', COALESCE(NEW.model_name, '')), 'A') ||
        setweight(to_tsvector('english', COALESCE(NEW.trim_name, '')), 'B');
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS vehicles_search_update ON vehicles;
CREATE TRIGGER vehicles_search_update 
    BEFORE INSERT OR UPDATE ON vehicles 
    FOR EACH ROW EXECUTE FUNCTION vehicles_search_trigger();

CREATE INDEX IF NOT EXISTS idx_vehicles_search ON vehicles USING GIN (search_vector);

-- Views
CREATE OR REPLACE VIEW vehicle_summary AS
SELECT
    v.id,
    v.unique_code,
    v.make_name || ' ' || v.model_name || ' ' || v.year::text AS display_name,
    v.make_slug,
    v.model_slug,
    v.year,
    v.trim_name,
    v.vehicle_type,
    v.drivetrain,
    v.battery_capacity_net_kwh,
    v.dc_max_power_kw,
    v.range_wltp_km,
    v.range_epa_km,
    v.acceleration_0_100_s,
    v.top_speed_kmh
FROM vehicles v;

CREATE OR REPLACE VIEW make_summary AS
SELECT
    make_slug,
    make_name,
    COUNT(*) as vehicle_count,
    MIN(year) as first_year,
    MAX(year) as latest_year
FROM vehicles
GROUP BY make_slug, make_name
ORDER BY make_name;

CREATE OR REPLACE VIEW model_summary AS
SELECT
    make_slug,
    make_name,
    model_slug,
    model_name,
    COUNT(*) as variant_count,
    MIN(year) as first_year,
    MAX(year) as latest_year,
    MAX(range_wltp_km) as max_range_km,
    MAX(dc_max_power_kw) as max_charging_kw
FROM vehicles
GROUP BY make_slug, make_name, model_slug, model_name
ORDER BY make_name, model_name;

-- Functions for common queries
CREATE OR REPLACE FUNCTION search_vehicles(query TEXT, limit_count INTEGER DEFAULT 20)
RETURNS SETOF vehicle_summary AS $$
BEGIN
    RETURN QUERY
    SELECT vs.*
    FROM vehicle_summary vs
    JOIN vehicles v ON v.id = vs.id
    WHERE v.search_vector @@ plainto_tsquery('english', query)
    ORDER BY ts_rank(v.search_vector, plainto_tsquery('english', query)) DESC
    LIMIT limit_count;
END;
$$ LANGUAGE plpgsql;

COMMIT;
