use std::io::Write;
use std::path::Path;

use anyhow::{Context, Result};
use ev_core::Vehicle;

pub fn generate(vehicles: &[Vehicle], output_path: &Path) -> Result<()> {
    let mut file = std::fs::File::create(output_path)
        .with_context(|| format!("Failed to create SQL file at {:?}", output_path))?;

    write_schema(&mut file)?;
    write_data(&mut file, vehicles)?;
    write_indexes(&mut file)?;
    write_views(&mut file)?;

    Ok(())
}

fn write_schema(file: &mut std::fs::File) -> Result<()> {
    writeln!(file, "-- OpenEV Data PostgreSQL Schema")?;
    writeln!(
        file,
        "-- Generated by ev-etl v{}",
        env!("CARGO_PKG_VERSION")
    )?;
    writeln!(file)?;
    writeln!(file, "BEGIN;")?;
    writeln!(file)?;

    writeln!(
        file,
        r#"
CREATE TABLE IF NOT EXISTS vehicles (
    id SERIAL PRIMARY KEY,
    unique_code VARCHAR(255) UNIQUE NOT NULL,
    make_slug VARCHAR(100) NOT NULL,
    make_name VARCHAR(255) NOT NULL,
    model_slug VARCHAR(100) NOT NULL,
    model_name VARCHAR(255) NOT NULL,
    year INTEGER NOT NULL,
    trim_slug VARCHAR(100) NOT NULL,
    trim_name VARCHAR(255) NOT NULL,
    variant_slug VARCHAR(100),
    variant_name VARCHAR(255),
    vehicle_type VARCHAR(50) NOT NULL,
    drivetrain VARCHAR(20) NOT NULL,
    system_power_kw DECIMAL(10,2),
    system_torque_nm DECIMAL(10,2),
    battery_capacity_gross_kwh DECIMAL(10,2),
    battery_capacity_net_kwh DECIMAL(10,2),
    battery_chemistry VARCHAR(100),
    dc_max_power_kw DECIMAL(10,2),
    ac_max_power_kw DECIMAL(10,2),
    range_wltp_km DECIMAL(10,2),
    range_epa_km DECIMAL(10,2),
    acceleration_0_100_s DECIMAL(5,2),
    top_speed_kmh DECIMAL(10,2),
    json_data JSONB NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE IF NOT EXISTS charge_ports (
    id SERIAL PRIMARY KEY,
    vehicle_id INTEGER NOT NULL REFERENCES vehicles(id) ON DELETE CASCADE,
    kind VARCHAR(50) NOT NULL,
    connector VARCHAR(50) NOT NULL,
    location_side VARCHAR(50),
    location_position VARCHAR(50)
);

CREATE TABLE IF NOT EXISTS range_ratings (
    id SERIAL PRIMARY KEY,
    vehicle_id INTEGER NOT NULL REFERENCES vehicles(id) ON DELETE CASCADE,
    cycle VARCHAR(50) NOT NULL,
    range_km DECIMAL(10,2) NOT NULL,
    notes TEXT
);

CREATE TABLE IF NOT EXISTS sources (
    id SERIAL PRIMARY KEY,
    vehicle_id INTEGER NOT NULL REFERENCES vehicles(id) ON DELETE CASCADE,
    source_type VARCHAR(50) NOT NULL,
    title TEXT NOT NULL,
    url TEXT NOT NULL,
    accessed_at TIMESTAMP WITH TIME ZONE NOT NULL,
    publisher VARCHAR(255)
);
"#
    )?;

    Ok(())
}

fn write_data(file: &mut std::fs::File, vehicles: &[Vehicle]) -> Result<()> {
    writeln!(file)?;
    writeln!(file, "-- Vehicle Data")?;

    for vehicle in vehicles {
        let unique_code = vehicle
            .unique_code
            .clone()
            .unwrap_or_else(|| vehicle.id().canonical_id());
        let json_data = serde_json::to_string(vehicle)?;
        let escaped_json = json_data.replace('\'', "''");

        let acceleration = vehicle
            .performance
            .as_ref()
            .and_then(|p| p.acceleration_0_100_kmh_s);
        let top_speed = vehicle.performance.as_ref().and_then(|p| p.top_speed_kmh);

        writeln!(
            file,
            "INSERT INTO vehicles (unique_code, make_slug, make_name, model_slug, model_name, year, trim_slug, trim_name, variant_slug, variant_name, vehicle_type, drivetrain, system_power_kw, system_torque_nm, battery_capacity_gross_kwh, battery_capacity_net_kwh, battery_chemistry, dc_max_power_kw, ac_max_power_kw, range_wltp_km, range_epa_km, acceleration_0_100_s, top_speed_kmh, json_data) VALUES ('{}', '{}', '{}', '{}', '{}', {}, '{}', '{}', {}, {}, '{}', '{}', {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, '{}');",
            escape_sql(&unique_code),
            escape_sql(&vehicle.make.slug),
            escape_sql(&vehicle.make.name),
            escape_sql(&vehicle.model.slug),
            escape_sql(&vehicle.model.name),
            vehicle.year,
            escape_sql(&vehicle.trim.slug),
            escape_sql(&vehicle.trim.name),
            vehicle
                .variant
                .as_ref()
                .map(|v| format!("'{}'", escape_sql(&v.slug)))
                .unwrap_or_else(|| "NULL".to_string()),
            vehicle
                .variant
                .as_ref()
                .map(|v| format!("'{}'", escape_sql(&v.name)))
                .unwrap_or_else(|| "NULL".to_string()),
            format!("{:?}", vehicle.vehicle_type),
            format!("{:?}", vehicle.powertrain.drivetrain),
            vehicle
                .powertrain
                .system_power_kw
                .map(|v| v.to_string())
                .unwrap_or_else(|| "NULL".to_string()),
            vehicle
                .powertrain
                .system_torque_nm
                .map(|v| v.to_string())
                .unwrap_or_else(|| "NULL".to_string()),
            vehicle
                .battery
                .pack_capacity_kwh_gross
                .map(|v| v.to_string())
                .unwrap_or_else(|| "NULL".to_string()),
            vehicle
                .battery
                .pack_capacity_kwh_net
                .map(|v| v.to_string())
                .unwrap_or_else(|| "NULL".to_string()),
            vehicle
                .battery
                .chemistry
                .as_ref()
                .map(|v| format!("'{}'", escape_sql(v)))
                .unwrap_or_else(|| "NULL".to_string()),
            vehicle
                .charging
                .dc
                .as_ref()
                .map(|dc| dc.max_power_kw.to_string())
                .unwrap_or_else(|| "NULL".to_string()),
            vehicle
                .charging
                .ac
                .as_ref()
                .map(|ac| ac.max_power_kw.to_string())
                .unwrap_or_else(|| "NULL".to_string()),
            vehicle
                .range
                .wltp_range_km()
                .map(|v| v.to_string())
                .unwrap_or_else(|| "NULL".to_string()),
            vehicle
                .range
                .epa_range_km()
                .map(|v| v.to_string())
                .unwrap_or_else(|| "NULL".to_string()),
            acceleration
                .map(|v| v.to_string())
                .unwrap_or_else(|| "NULL".to_string()),
            top_speed
                .map(|v| v.to_string())
                .unwrap_or_else(|| "NULL".to_string()),
            escaped_json,
        )?;
    }

    Ok(())
}

fn write_indexes(file: &mut std::fs::File) -> Result<()> {
    writeln!(file)?;
    writeln!(file, "-- Indexes")?;
    writeln!(
        file,
        "CREATE INDEX IF NOT EXISTS idx_vehicles_make ON vehicles(make_slug);"
    )?;
    writeln!(
        file,
        "CREATE INDEX IF NOT EXISTS idx_vehicles_model ON vehicles(model_slug);"
    )?;
    writeln!(
        file,
        "CREATE INDEX IF NOT EXISTS idx_vehicles_year ON vehicles(year);"
    )?;
    writeln!(
        file,
        "CREATE INDEX IF NOT EXISTS idx_vehicles_composite ON vehicles(make_slug, model_slug, year, trim_slug);"
    )?;
    writeln!(
        file,
        "CREATE INDEX IF NOT EXISTS idx_vehicles_type ON vehicles(vehicle_type);"
    )?;
    writeln!(
        file,
        "CREATE INDEX IF NOT EXISTS idx_vehicles_json ON vehicles USING GIN (json_data);"
    )?;
    writeln!(
        file,
        "CREATE INDEX IF NOT EXISTS idx_charge_ports_vehicle ON charge_ports(vehicle_id);"
    )?;
    writeln!(
        file,
        "CREATE INDEX IF NOT EXISTS idx_range_ratings_vehicle ON range_ratings(vehicle_id);"
    )?;
    writeln!(
        file,
        "CREATE INDEX IF NOT EXISTS idx_sources_vehicle ON sources(vehicle_id);"
    )?;

    Ok(())
}

fn write_views(file: &mut std::fs::File) -> Result<()> {
    writeln!(file)?;
    writeln!(file, "-- Views")?;
    writeln!(
        file,
        r#"
CREATE OR REPLACE VIEW vehicle_summary AS
SELECT
    v.id,
    v.unique_code,
    v.make_name || ' ' || v.model_name || ' ' || v.year AS display_name,
    v.make_slug,
    v.model_slug,
    v.year,
    v.trim_name,
    v.vehicle_type,
    v.drivetrain,
    v.battery_capacity_net_kwh,
    v.dc_max_power_kw,
    v.range_wltp_km,
    v.range_epa_km
FROM vehicles v;
"#
    )?;

    writeln!(file)?;
    writeln!(file, "COMMIT;")?;

    Ok(())
}

fn escape_sql(s: &str) -> String {
    s.replace('\'', "''")
}
